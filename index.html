<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>宇宙飞船探索者 - 优化版</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
            color: #fff;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        .ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }
        h1 {
            font-size: 18px;
            margin: 0 0 10px 0;
        }
        .speed-control {
            margin: 10px 0;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #fff;
        }
    </style>
</head>
<body>
    <div class="loading">生成宇宙中...</div>
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui-container">
        <h1>宇宙飞船探索者</h1>
        <div>速度: <span id="speedDisplay">1.0</span> 光年/秒</div>
        <div>已飞行: <span id="distanceDisplay">0</span> 光年</div>
        <div>区域: <span id="regionDisplay">太阳系</span></div>
        <div>对象数: <span id="objectCount">0</span></div>
    </div>
    
    <div class="controls">
        <div>方向控制: WASD 或 箭头键</div>
        <div>速度控制: +/- 键</div>
    </div>

    <script>
        // 获取Canvas和上下文
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // 设置Canvas尺寸为窗口大小
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // 游戏常量
        const BUFFER_ZONE = 500; // 屏幕外缓冲区大小
        const REGION_SIZE = 1000; // 每个区域的大小（光年）
        
        // 游戏状态
        const state = {
            ship: {
                x: 0, // 宇宙坐标
                y: 0,
                speed: 1.0,
                direction: { x: 0, y: 0 },
                size: 20
            },
            camera: {
                x: 0,
                y: 0
            },
            distance: 0,
            region: '太阳系',
            regions: ['太阳系', '柯伊伯带', '奥尔特云', '星际空间', '比邻星系', '银河系内部'],
            objects: new Map(), // 使用Map存储所有对象，键为坐标字符串
            lastTimestamp: 0,
            loading: true
        };
        
        // 行星颜色调色板
        const planetColors = [
            '#a52a2a', '#ffd700', '#0000ff', '#ff4500', '#ffa500', 
            '#ffff00', '#add8e6', '#1e90ff', '#a9a9a9', '#696969',
            '#2f4f4f', '#778899', '#708090', '#d2b48c', '#bc8f8f',
            '#f0e68c', '#9370db', '#ba55d3', '#da70d6', '#ee82ee',
            '#ff6347', '#ff7f50', '#ff8c00', '#ff69b4', '#ff1493',
            '#c71585', '#dc143c', '#00ced1', '#00bfff', '#1e90ff'
        ];
        
        // 生成基于坐标的哈希键
        function getKey(x, y) {
            return `${Math.floor(x/100)}_${Math.floor(y/100)}`;
        }
        
        // 生成指定区域的对象
        function generateAreaObjects(centerX, centerY, radius) {
            const newObjects = [];
            
            // 计算区域边界
            const minX = centerX - radius;
            const maxX = centerX + radius;
            const minY = centerY - radius;
            const maxY = centerY + radius;
            
            // 根据区域密度生成对象
            const regionIndex = Math.min(Math.floor(state.distance / REGION_SIZE), state.regions.length - 1);
            const region = state.regions[regionIndex];
            
            // 不同区域有不同的对象密度
            let density = 0;
            switch(region) {
                case '太阳系': density = 0.00005; break;
                case '柯伊伯带': density = 0.0001; break;
                case '奥尔特云': density = 0.00008; break;
                case '星际空间': density = 0.00003; break;
                case '比邻星系': density = 0.00006; break;
                case '银河系内部': density = 0.0002; break;
            }
            
            // 计算区域面积
            const area = (maxX - minX) * (maxY - minY);
            const objectCount = Math.floor(area * density);
            
            // 生成星星和行星
            for (let i = 0; i < objectCount; i++) {
                const x = minX + Math.random() * (maxX - minX);
                const y = minY + Math.random() * (maxY - minY);
                
                // 80%的几率生成星星，20%的几率生成行星
                if (Math.random() < 0.8) {
                    // 星星
                    newObjects.push({
                        x,
                        y,
                        type: 'star',
                        size: Math.random() * 3 + 0.5,
                        brightness: Math.random() * 0.5 + 0.5,
                        speed: 0.1 + Math.random() * 0.3,
                        color: `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.5})`
                    });
                } else {
                    // 行星
                    newObjects.push({
                        x,
                        y,
                        type: 'planet',
                        size: 10 + Math.random() * 30,
                        color: planetColors[Math.floor(Math.random() * planetColors.length)],
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.01,
                        hasRing: Math.random() > 0.7
                    });
                }
            }
            
            return newObjects;
        }
        
        // 加载视口及缓冲区内的对象
        function loadVisibleObjects() {
            // 计算视口边界（包括缓冲区）
            const viewportLeft = state.camera.x - BUFFER_ZONE;
            const viewportRight = state.camera.x + canvas.width + BUFFER_ZONE;
            const viewportTop = state.camera.y - BUFFER_ZONE;
            const viewportBottom = state.camera.y + canvas.height + BUFFER_ZONE;
            
            // 计算需要加载的区域
            const sectorSize = 500;
            const startSectorX = Math.floor(viewportLeft / sectorSize);
            const endSectorX = Math.floor(viewportRight / sectorSize);
            const startSectorY = Math.floor(viewportTop / sectorSize);
            const endSectorY = Math.floor(viewportBottom / sectorSize);
            
            // 加载这些区域的对象
            for (let x = startSectorX; x <= endSectorX; x++) {
                for (let y = startSectorY; y <= endSectorY; y++) {
                    const key = `${x}_${y}`;
                    
                    // 如果这个区域还没有生成对象，则生成
                    if (!state.objects.has(key)) {
                        const centerX = (x + 0.5) * sectorSize;
                        const centerY = (y + 0.5) * sectorSize;
                        const objects = generateAreaObjects(centerX, centerY, sectorSize / 2);
                        state.objects.set(key, objects);
                    }
                }
            }
            
            // 卸载远离视口的对象以节省内存
            const unloadSectorRadius = 5; // 卸载视口外5个区域以外的对象
            for (const [key, sectorObjects] of state.objects) {
                const [sectorX, sectorY] = key.split('_').map(Number);
                
                // 如果这个区域远离当前视口，则卸载
                if (sectorX < startSectorX - unloadSectorRadius || 
                    sectorX > endSectorX + unloadSectorRadius ||
                    sectorY < startSectorY - unloadSectorRadius || 
                    sectorY > endSectorY + unloadSectorRadius) {
                    state.objects.delete(key);
                }
            }
            
            // 更新对象计数显示
            let totalObjects = 0;
            for (const [, objects] of state.objects) {
                totalObjects += objects.length;
            }
            document.getElementById('objectCount').textContent = totalObjects;
        }
        
        // 更新区域
        function updateRegion() {
            const regionIndex = Math.min(Math.floor(state.distance / REGION_SIZE), state.regions.length - 1);
            if (state.region !== state.regions[regionIndex]) {
                state.region = state.regions[regionIndex];
                document.getElementById('regionDisplay').textContent = state.region;
                
                // 区域改变时重新生成所有对象
                state.objects.clear();
                loadVisibleObjects();
            }
        }
        
        // 初始化游戏
        function init() {
            // 事件监听
            window.addEventListener('keydown', handleKeyDown);
            // window.addEventListener('keyup', handleKeyUp);
            window.addEventListener('resize', handleResize);
            
            // 初始加载对象
            loadVisibleObjects();
            
            // 隐藏加载提示
            setTimeout(() => {
                state.loading = false;
                document.querySelector('.loading').style.display = 'none';
            }, 1000);
            
            // 开始游戏循环
            requestAnimationFrame(gameLoop);
        }
        
        // 处理按键按下
        function handleKeyDown(e) {
            const speedChange = 0.05;
            
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    state.ship.direction.y -= speedChange;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    state.ship.direction.y += speedChange;
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    state.ship.direction.x -= speedChange;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    state.ship.direction.x += speedChange;
                    break;
                case '+':
                case '=':
                    state.ship.speed = Math.min(5, state.ship.speed + 0.1);
                    updateSpeedDisplay();
                    break;
                case '-':
                case '_':
                    state.ship.speed = Math.max(0.1, state.ship.speed - 0.1);
                    updateSpeedDisplay();
                    break;
            }
            
            // 确保方向值不会过大
            state.ship.direction.x = Math.max(-1, Math.min(1, state.ship.direction.x));
            state.ship.direction.y = Math.max(-1, Math.min(1, state.ship.direction.y));
        }
        
        // 处理按键释放
        function handleKeyUp(e) {
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                case 'ArrowDown':
                case 's':
                case 'S':
                    state.ship.direction.y = 0;
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                case 'ArrowRight':
                case 'd':
                case 'D':
                    state.ship.direction.x = 0;
                    break;
            }
        }
        
        // 处理窗口大小变化
        function handleResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        // 更新速度显示
        function updateSpeedDisplay() {
            document.getElementById('speedDisplay').textContent = state.ship.speed.toFixed(1);
        }
        
        // 更新距离显示
        function updateDistanceDisplay() {
            document.getElementById('distanceDisplay').textContent = Math.floor(state.distance);
        }
        
        // 游戏更新逻辑
        function update(timestamp) {
            // 计算帧时间差
            const deltaTime = state.lastTimestamp ? (timestamp - state.lastTimestamp) / 1000 : 0;
            state.lastTimestamp = timestamp;
            
            if (deltaTime > 0.1) return; // 避免长时间暂停后的大幅跳跃
            
            // 更新飞船宇宙坐标
            state.ship.x += state.ship.direction.x * state.ship.speed * 100 * deltaTime;
            state.ship.y += state.ship.direction.y * state.ship.speed * 100 * deltaTime;
            
            // 更新相机位置（跟随飞船）
            state.camera.x = state.ship.x - canvas.width / 2;
            state.camera.y = state.ship.y - canvas.height / 2;
            
            // 更新飞行距离
            state.distance += state.ship.speed * deltaTime;
            updateDistanceDisplay();
            
            // 更新区域
            updateRegion();
            
            // 加载可见对象
            loadVisibleObjects();
            
            // 更新行星旋转
            for (const [, objects] of state.objects) {
                for (const obj of objects) {
                    if (obj.type === 'planet') {
                        obj.rotation += obj.rotationSpeed * deltaTime;
                    }
                }
            }
        }
        
        // 渲染游戏
        function render() {
            // 清除画布
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 渲染所有可见对象
            for (const [, objects] of state.objects) {
                for (const obj of objects) {
                    // 计算对象在屏幕上的位置
                    const screenX = obj.x - state.camera.x;
                    const screenY = obj.y - state.camera.y;
                    
                    // 只渲染在屏幕及缓冲区内的对象
                    if (screenX >= -BUFFER_ZONE && screenX <= canvas.width + BUFFER_ZONE &&
                        screenY >= -BUFFER_ZONE && screenY <= canvas.height + BUFFER_ZONE) {
                        
                        if (obj.type === 'star') {
                            // 渲染星星
                            const brightness = 0.5 + 0.5 * Math.sin(state.distance * 0.1 + obj.x * 0.01);
                            ctx.fillStyle = `rgba(255, 255, 255, ${obj.brightness * brightness})`;
                            ctx.beginPath();
                            ctx.arc(screenX, screenY, obj.size, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (obj.type === 'planet') {
                            // 渲染行星
                            ctx.fillStyle = obj.color;
                            ctx.beginPath();
                            ctx.arc(screenX, screenY, obj.size, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // 行星纹理
                            ctx.strokeStyle = `rgba(0, 0, 0, 0.3)`;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(screenX, screenY, obj.size, 0, Math.PI * 2);
                            ctx.stroke();
                            
                            // 行星光环
                            if (obj.hasRing) {
                                ctx.strokeStyle = `rgba(255, 255, 255, 0.5)`;
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.arc(screenX, screenY, obj.size * 1.5, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                        }
                    }
                }
            }
            
            // 渲染飞船（始终在屏幕中央）
            renderShip();
        }
        
        // 渲染飞船
        function renderShip() {
            const x = canvas.width / 2;
            const y = canvas.height / 2;
            const size = state.ship.size;
            
            // 飞船主体
            ctx.fillStyle = '#3498db';
            ctx.beginPath();
            ctx.moveTo(x, y - size);
            ctx.lineTo(x + size, y + size);
            ctx.lineTo(x - size, y + size);
            ctx.closePath();
            ctx.fill();
            
            // 飞船细节
            ctx.strokeStyle = '#2980b9';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y - size);
            ctx.lineTo(x + size, y + size);
            ctx.lineTo(x - size, y + size);
            ctx.closePath();
            ctx.stroke();
            
            // 飞船引擎光效
            const enginePower = 0.5 + 0.5 * Math.sin(state.distance * 10);
            ctx.fillStyle = `rgba(255, 100, 0, ${enginePower})`;
            ctx.beginPath();
            ctx.moveTo(x - size * 0.5, y + size);
            ctx.lineTo(x + size * 0.5, y + size);
            ctx.lineTo(x, y + size * 2);
            ctx.closePath();
            ctx.fill();
        }
        
        // 游戏循环
        function gameLoop(timestamp) {
            update(timestamp);
            render();
            requestAnimationFrame(gameLoop);
        }
        
        // 启动游戏
        init();
    </script>
</body>
</html>
